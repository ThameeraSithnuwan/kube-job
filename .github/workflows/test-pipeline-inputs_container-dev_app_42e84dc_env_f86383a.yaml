name: >-
  test-pipeline-inputs_container-dev_app_42e84dc_env_f86383a Pipeline (Skyu
  Generated)
'on':
  push:
    branches:
      - master
    paths:
      - 'packages/backend/**'
    paths-ignore:
      - .trivyignore
      - Readme.md
      - README.md
  workflow_dispatch: {}
  repository_dispatch:
    types: pipeline_fcdb47f7-ec13-4c8c-a137-99cd0e5f4eb8
env:
  ENCODED_PIPELINE_SECRET: ${{secrets.KUBEJOB_TESTPIPELINEINPUTS_CONTAINERDEV_APP_42E84DC_ENV_F86383A}}
  COMMIT_ID: ${{github.event.client_payload.commitId || github.sha || github.run_id}}
  BRANCH_NAME: >-
    ${{github.event.client_payload.branchName || github.event.branch ||
    github.ref_name}}
  DEPLOY_STEP_SHOULD_DEPLOY: 'true'
  API_URL: ${{secrets.QA_LIQUIBASE_RUNNER_API_URL}}
  API_TOKEN: ${{secrets.QA_API_TOKEN}}
jobs:
  database-deployment:
      name: Database Deployment
      runs-on: ubuntu-latest
      steps:
        - name: 'Run :: Start'
          run: |2-
  
                echo " Starting GitHub Action!" && 
                echo "STEPS_CAN_PROCEED=true" >> $GITHUB_ENV
                
        - name: 'Run :: Checkout repository'
          uses: actions/checkout@v4
          with:
            fetch-depth: 0
        - name: 'Run :: Checkout Specific Commit'
          env:
            COMMIT_ID: ${{ github.event.client_payload.commitId }}
            BRANCH_NAME: ${{ github.event.client_payload.branchName }}
          if: >-
            ${{ github.event.client_payload.commitId != null ||
            github.event.client_payload.branchName != null }}
          run: |2-
  
                echo "Starting the checkout process..."
                git fetch --all
                if [ -n "$COMMIT_ID" ]; then
                  echo "Commit ID provided: $COMMIT_ID"
                  git checkout $COMMIT_ID || true
                  echo "Checked out to commit ID: $COMMIT_ID"
                elif [ -n "$BRANCH_NAME" ]; then
                  echo "Branch name provided: $BRANCH_NAME"
                  git checkout $BRANCH_NAME || true
                  echo "Checked out to branch: $BRANCH_NAME"
  
                  #Updating the commit Id
                  ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                  echo "Changing CommitId: $ACTUAL_COMMIT_ID"
                  echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
                else
                  echo "Skipping checkout..."
                fi

  code-scan:
    name: Code Scan
    runs-on: ubuntu-latest
    permissions: write-all
    needs: 
      - database-deployment
    steps:
      - name: 'Run :: Checkout repository for Code Scan'
        uses: actions/checkout@v4
      - name: 'Run :: Checkout Specific Commit'
        env:
          COMMIT_ID: ${{ github.event.client_payload.commitId }}
          BRANCH_NAME: ${{ github.event.client_payload.branchName }}
          TICKETS: ${{ github.event.client_payload.tickets }}
        if: >-
          ${{ github.event.client_payload.commitId != null ||
              github.event.client_payload.tickets != null ||
              github.event.client_payload.branchName != null }}
        run: |2-

              echo "Starting the checkout process..."
              git fetch --all
              if [ -n "$TICKETS" ]; then
                # git really wants these for merges, but we are not going to push, so they don't really matter
                git config --global user.email "do.not.use@example.com"
                git config --global user.name "${{ github.actor }}"
      
                readarray -d , -t tickets <<< "${{ github.event.client_payload.tickets }}"
                for t in ${tickets[@]}
                do
                  echo "Trying to merge branch for $t"
                  branch=$(git branch -r | grep -o "origin/$t.*") || (echo "No branch found, exiting"; exit -1)
                  echo "Found $branch"
                  branches="$branches\n* $branch"
                  if [ $(wc -l <<< $branch) -ne "1" ]; then echo "Expecting to find only one branch, aborting"; exit -2; fi
                  remote="${branch%%/*}"
                  remote_branch="${branch#*/}"
      
                  echo "Merging lint counts"
                  # Update the lint counts to match the target so we dont get conflicts
                  git checkout -f $remote/$remote_branch -- packages/backend/lint-state.txt
                  git checkout -f $remote/$remote_branch -- packages/web/lint-state.txt
                  git commit -m "Merge Lint Counts" || echo "No lint changes to commit"
      
                  echo "Merging remote branch"
                  git fetch $remote $remote_branch || exit -3
                  git merge $remote/$remote_branch || exit -4

                done
                # Update COMMIT_ID after merge
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Updated CommitId after merge: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
                echo "branches=${branches}" >> "$GITHUB_ENV"
              elif [ -n "$COMMIT_ID" ]; then
                echo "Commit ID provided: $COMMIT_ID"
                git checkout $COMMIT_ID || true
                echo "Checked out to commit ID: $COMMIT_ID"
              elif [ -n "$BRANCH_NAME" ]; then
                echo "Branch name provided: $BRANCH_NAME"
                git checkout $BRANCH_NAME || true
                echo "Checked out to branch: $BRANCH_NAME"

                #Updating the commit Id
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Changing CommitId: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
              else
                echo "Skipping checkout..."
              fi
            
      - name: 'Run :: Decoding Secrets'
        run: |2-
                echo "testing"
                echo "${{ github.event.client_payload.tickets }}"
                echo "Listing current directory files:"
                ls -la
                echo "Listing current directory files:"
