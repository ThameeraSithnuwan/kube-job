name: >-
  test-pipeline-inputs_container-dev_app_42e84dc_env_f86383a Pipeline (Skyu
  Generated)
'on':
  push:
    branches:
      - master
    paths-ignore:
      - .github/workflows/**
      - .trivyignore
      - Readme.md
      - README.md
  workflow_dispatch: {}
  repository_dispatch:
    types: pipeline_fcdb47f7-ec13-4c8c-a137-99cd0e5f4eb8
env:
  ENCODED_PIPELINE_SECRET: ${{secrets.KUBEJOB_TESTPIPELINEINPUTS_CONTAINERDEV_APP_42E84DC_ENV_F86383A}}
  COMMIT_ID: ${{github.event.client_payload.commitId || github.sha || github.run_id}}
  BRANCH_NAME: >-
    ${{github.event.client_payload.branchName || github.event.branch ||
    github.ref_name}}
  DEPLOY_STEP_SHOULD_DEPLOY: 'true'
  API_URL: 'https://rtcaws-qa.rtcmgmt.com/liquibase-runner-service'
  API_TOKEN: test
jobs:
  db-migration:
      name: Database Migration
      runs-on: ubuntu-latest
      outputs:
        migration_status: ${{ steps.monitor.outcome == 'success' && 'success' || 'failed' }}
      steps:
        - name: Trigger Deployment
          id: trigger
          run: |
            response=$(curl -s -X POST "$API_URL/deploy" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $API_TOKEN" \
              -d '{
                "repo_url": "https://github.com/realtimeconveyancer/realtime-matters-service.git",
                "liquibase_envs": {
                  "DB_HOST": "rtc-app-realtime-matter-service.ch6wiqqislb8.ap-southeast-2.rds.amazonaws.com",
                  "DB_PORT": 5432,
                  "DB_NAME": "realtimematterdb",
                  "DB_USER": "realtimeuser",
                  "DB_PASS": "${{ secrets.DB_PASSWORD }}",
                  "CHANGELOG_FILE": "liquibase/changelogs/changelog.master.xml"
                },
                "env_filename": ".env.production",
                "liquibase_exec_cmd": "npm i && cd liquibase && npm i && cd .. && npm run liquibase:deploy",
                "commit_id": "${{ github.event.inputs.commit_id }}"
              }')
            
            job_name=$(echo "$response" | jq -r '.job')
            if [ -z "$job_name" ] || [ "$job_name" = "null" ]; then
              echo "Error: Failed to get job name"
              echo "Response: $response"
              exit 1
            fi
            
            echo "job_name=$job_name" >> $GITHUB_OUTPUT
            echo "Deployment triggered. Job name: $job_name"
  
        - name: Monitor Job Status
          id: monitor
          run: |
            job_name=${{ steps.trigger.outputs.job_name }}
            max_attempts=30  # 30 attempts * 10 seconds = 5 minutes max
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Checking job status (Attempt $attempt/$max_attempts)..."
              
              response=$(curl -s -X GET "$API_URL/job/$job_name/latest-pod" \
                -H "Authorization: Bearer $API_TOKEN")
              
              pod_status=$(echo "$response" | jq -r '.latestPod.containerStatus | to_entries[0].value.reason // "UNKNOWN"')
              phase=$(echo "$response" | jq -r '.latestPod.phase')
              
              echo "Current status - Phase: $phase, Container Status: $pod_status"
              
              if [ "$phase" = "Succeeded" ]; then
                echo "✅ Database migration completed successfully!"
                exit 0
              fi
              
              if [ "$phase" = "Failed" ] || [ "$pod_status" = "Error" ] || [ "$pod_status" = "CrashLoopBackOff" ]; then
                echo "❌ Database migration failed with status: $pod_status"
                echo "Debug info:"
                echo "$response" | jq .
                exit 1
              fi
              
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "❌ Database migration timed out after $((max_attempts * 10)) seconds"
            exit 1
  code-scan:
    name: Code Scan
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
      - name: 'Run :: Checkout repository for Code Scan'
        uses: actions/checkout@v4
      - name: 'Run :: Checkout Specific Commit'
        env:
          COMMIT_ID: ${{ github.event.client_payload.commitId }}
          BRANCH_NAME: ${{ github.event.client_payload.branchName }}
          TICKETS: ${{ github.event.client_payload.tickets }}
        if: >-
          ${{ github.event.client_payload.commitId != null ||
              github.event.client_payload.tickets != null ||
              github.event.client_payload.branchName != null }}
        run: |2-

              echo "Starting the checkout process..."
              git fetch --all
              if [ -n "$TICKETS" ]; then
                # git really wants these for merges, but we are not going to push, so they don't really matter
                git config --global user.email "do.not.use@example.com"
                git config --global user.name "${{ github.actor }}"
      
                readarray -d , -t tickets <<< "${{ github.event.client_payload.tickets }}"
                for t in ${tickets[@]}
                do
                  echo "Trying to merge branch for $t"
                  branch=$(git branch -r | grep -o "origin/$t.*") || (echo "No branch found, exiting"; exit -1)
                  echo "Found $branch"
                  branches="$branches\n* $branch"
                  if [ $(wc -l <<< $branch) -ne "1" ]; then echo "Expecting to find only one branch, aborting"; exit -2; fi
                  remote="${branch%%/*}"
                  remote_branch="${branch#*/}"
      
                  echo "Merging lint counts"
                  # Update the lint counts to match the target so we dont get conflicts
                  git checkout -f $remote/$remote_branch -- packages/backend/lint-state.txt
                  git checkout -f $remote/$remote_branch -- packages/web/lint-state.txt
                  git commit -m "Merge Lint Counts" || echo "No lint changes to commit"
      
                  echo "Merging remote branch"
                  git fetch $remote $remote_branch || exit -3
                  git merge $remote/$remote_branch || exit -4

                done
                # Update COMMIT_ID after merge
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Updated CommitId after merge: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
                echo "branches=${branches}" >> "$GITHUB_ENV"
              elif [ -n "$COMMIT_ID" ]; then
                echo "Commit ID provided: $COMMIT_ID"
                git checkout $COMMIT_ID || true
                echo "Checked out to commit ID: $COMMIT_ID"
              elif [ -n "$BRANCH_NAME" ]; then
                echo "Branch name provided: $BRANCH_NAME"
                git checkout $BRANCH_NAME || true
                echo "Checked out to branch: $BRANCH_NAME"

                #Updating the commit Id
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Changing CommitId: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
              else
                echo "Skipping checkout..."
              fi
            
      - name: 'Run :: Decoding Secrets'
        run: |2-

                echo "testing"
                echo "${{ github.event.client_payload.tickets }}"
                echo "Listing current directory files:"
                ls -la
                echo "Listing current directory files:"

                
                  
  
