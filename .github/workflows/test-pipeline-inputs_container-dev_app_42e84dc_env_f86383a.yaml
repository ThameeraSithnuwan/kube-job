name: >-
  test-pipeline-inputs_container-dev_app_42e84dc_env_f86383a Pipeline (Skyu
  Generated)
'on':
  push:
    branches:
      - master
    paths-ignore:
      - .github/workflows/**
      - .trivyignore
      - Readme.md
      - README.md
  workflow_dispatch: {}
  repository_dispatch:
    types: pipeline_fcdb47f7-ec13-4c8c-a137-99cd0e5f4eb8
env:
  ENCODED_PIPELINE_SECRET: ${{secrets.KUBEJOB_TESTPIPELINEINPUTS_CONTAINERDEV_APP_42E84DC_ENV_F86383A}}
  COMMIT_ID: ${{github.event.client_payload.commitId || github.sha || github.run_id}}
  BRANCH_NAME: >-
    ${{github.event.client_payload.branchName || github.event.branch ||
    github.ref_name}}
  DEPLOY_STEP_SHOULD_DEPLOY: 'true'
  API_URL: ${{secrets.PROD_LIQUIBASE_RUNNER_API_URL}}
  API_TOKEN: ${{secrets.PROD_API_TOKEN}}
jobs:
  database-deployment:
      name: Database Deployment
      runs-on: ubuntu-latest
      steps:
        - name: 'Run :: Start'
          run: |2-
  
                echo " Starting GitHub Action!" && 
                echo "STEPS_CAN_PROCEED=true" >> $GITHUB_ENV
                
        - name: 'Run :: Checkout repository'
          uses: actions/checkout@v4
          with:
            fetch-depth: 0
        - name: 'Run :: Checkout Specific Commit'
          env:
            COMMIT_ID: ${{ github.event.client_payload.commitId }}
            BRANCH_NAME: ${{ github.event.client_payload.branchName }}
          if: >-
            ${{ github.event.client_payload.commitId != null ||
            github.event.client_payload.branchName != null }}
          run: |2-
  
                echo "Starting the checkout process..."
                git fetch --all
                if [ -n "$COMMIT_ID" ]; then
                  echo "Commit ID provided: $COMMIT_ID"
                  git checkout $COMMIT_ID || true
                  echo "Checked out to commit ID: $COMMIT_ID"
                elif [ -n "$BRANCH_NAME" ]; then
                  echo "Branch name provided: $BRANCH_NAME"
                  git checkout $BRANCH_NAME || true
                  echo "Checked out to branch: $BRANCH_NAME"
  
                  #Updating the commit Id
                  ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                  echo "Changing CommitId: $ACTUAL_COMMIT_ID"
                  echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
                else
                  echo "Skipping checkout..."
                fi
        - name: Trigger Database Deployment
          id: trigger
          run: |
            response=$(curl -s -X POST "$API_URL/deploy" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $API_TOKEN" \
              -d '{
                "repo_url": "https://github.com/realtimeconveyancer/realtime-matters-service.git",
                "liquibase_envs": {
                  "DB_HOST": "${{ secrets.PROD_DB_HOST }}",
                  "DB_PORT": 5432,
                  "DB_NAME": "${{ secrets.DB_NAME }}",
                  "DB_USER": "${{ secrets.DB_USER }}",
                  "DB_PASS": "${{ secrets.PROD_DB_PASS }}",
                  "CHANGELOG_FILE": "liquibase/changelogs/changelog.master.xml"
                },
                "env_filename": "${{ secrets.ENV_FILENAME }}",
                "liquibase_exec_cmd": "${{ secrets.EXEC_CMD }}",
                "commit_id": ""
              }')
            
            job_name=$(echo "$response" | jq -r '.job')
            if [ -z "$job_name" ] || [ "$job_name" = "null" ]; then
              echo "Error: Failed to get job name"
              echo "Response: $response"
              exit 1
            fi
            
            echo "job_name=$job_name" >> $GITHUB_OUTPUT
            echo "Database Deployment triggered. Job name: $job_name"
  
        - name: Check Database Deployment Job Status
          run: |
            job_name=${{ steps.trigger.outputs.job_name }}
            max_attempts=60
            attempt=1
                        
            while [ $attempt -le $max_attempts ]; do
              echo "Checking job status (Attempt $attempt/$max_attempts)..."
            
              response=$(curl -s -X GET "$API_URL/job/$job_name/status" \
                -H "Authorization: Bearer $API_TOKEN")
            
              # Validate JSON
              if ! echo "$response" | jq empty >/dev/null 2>&1; then
                echo "Invalid JSON response:"
                echo "$response"
                exit 1
              fi
            
              job_status=$(echo "$response" | jq -r '.job.status // "UNKNOWN"')
            
              echo "Current job status: $job_status"
            
              if [ "$job_status" = "Succeeded" ]; then
                echo "Database deployment completed successfully!"
                exit 0
              fi
            
              if [ "$job_status" = "Failed" ]; then
                echo "Database deployment failed!"
                echo "Debug info:"
                echo "$response" | jq .
                exit 1
              fi
            
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "Database deployment timed out after $((max_attempts * 10)) seconds"
            exit 1
  code-scan:
    name: Code Scan
    runs-on: ubuntu-latest
    permissions: write-all
    needs: 
      - database-deployment
    steps:
      - name: 'Run :: Checkout repository for Code Scan'
        uses: actions/checkout@v4
      - name: 'Run :: Checkout Specific Commit'
        env:
          COMMIT_ID: ${{ github.event.client_payload.commitId }}
          BRANCH_NAME: ${{ github.event.client_payload.branchName }}
          TICKETS: ${{ github.event.client_payload.tickets }}
        if: >-
          ${{ github.event.client_payload.commitId != null ||
              github.event.client_payload.tickets != null ||
              github.event.client_payload.branchName != null }}
        run: |2-

              echo "Starting the checkout process..."
              git fetch --all
              if [ -n "$TICKETS" ]; then
                # git really wants these for merges, but we are not going to push, so they don't really matter
                git config --global user.email "do.not.use@example.com"
                git config --global user.name "${{ github.actor }}"
      
                readarray -d , -t tickets <<< "${{ github.event.client_payload.tickets }}"
                for t in ${tickets[@]}
                do
                  echo "Trying to merge branch for $t"
                  branch=$(git branch -r | grep -o "origin/$t.*") || (echo "No branch found, exiting"; exit -1)
                  echo "Found $branch"
                  branches="$branches\n* $branch"
                  if [ $(wc -l <<< $branch) -ne "1" ]; then echo "Expecting to find only one branch, aborting"; exit -2; fi
                  remote="${branch%%/*}"
                  remote_branch="${branch#*/}"
      
                  echo "Merging lint counts"
                  # Update the lint counts to match the target so we dont get conflicts
                  git checkout -f $remote/$remote_branch -- packages/backend/lint-state.txt
                  git checkout -f $remote/$remote_branch -- packages/web/lint-state.txt
                  git commit -m "Merge Lint Counts" || echo "No lint changes to commit"
      
                  echo "Merging remote branch"
                  git fetch $remote $remote_branch || exit -3
                  git merge $remote/$remote_branch || exit -4

                done
                # Update COMMIT_ID after merge
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Updated CommitId after merge: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
                echo "branches=${branches}" >> "$GITHUB_ENV"
              elif [ -n "$COMMIT_ID" ]; then
                echo "Commit ID provided: $COMMIT_ID"
                git checkout $COMMIT_ID || true
                echo "Checked out to commit ID: $COMMIT_ID"
              elif [ -n "$BRANCH_NAME" ]; then
                echo "Branch name provided: $BRANCH_NAME"
                git checkout $BRANCH_NAME || true
                echo "Checked out to branch: $BRANCH_NAME"

                #Updating the commit Id
                ACTUAL_COMMIT_ID=$(git rev-parse HEAD)
                echo "Changing CommitId: $ACTUAL_COMMIT_ID"
                echo "COMMIT_ID=$ACTUAL_COMMIT_ID" >> $GITHUB_ENV
              else
                echo "Skipping checkout..."
              fi
            
      - name: 'Run :: Decoding Secrets'
        run: |2-

                echo "testing"
                echo "${{ github.event.client_payload.tickets }}"
                echo "Listing current directory files:"
                ls -la
                echo "Listing current directory files:"

                
                  
  
